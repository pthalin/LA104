/**********************(C) COPYRIGHT 2017 e-Design Co.,Ltd.*********************
 * FileName    : Func.c
 * Description : 
 * Author      : SNAKE 
 * History     :
*******************************************************************************/
#include "MyDefine.h"
#include "Func.h"


/*******************************************************************************
 * FunctionName : Rev16
 * Description  : 16 bites 大端模式数据转换为小端模式
 * Param        : u16* pBuf 
*******************************************************************************/
void Rev16(u16 *pBuf)
{
    asm(" LDRH    R1, [R0] ");
    asm(" REV16   R1, R1 ");
    asm(" STRH    R1, [R0] ");
}

/*******************************************************************************
 * FunctionName : Rev32
 * Description  : 32 bites 大端模式数据转换为小端模式
 * Param        : u32* pBuf 
*******************************************************************************/
void Rev32(u32 *pBuf)
{
    asm(" LDR     R1, [R0] ");
    asm(" REV     R1, R1 ");
    asm(" STR     R1, [R0] ");
}

/*******************************************************************************
 * FunctionName : Power
 * Description  : 计算 x 的 y 次方
 * Param        : u8 x 
 * Param        : u8 y 
 * Return       : u32   
*******************************************************************************/
u32 Power(u8 x, u8 y)
{
    u32 m = x;

    if (y == 0) return 1;
    while (--y) m *= x;
    return m;
}

/*******************************************************************************
 * FunctionName : Exp
 * Description  : 计算 10 的 x 次方
 * Param        : u8 x 
 * Return       : u32   
*******************************************************************************/
u32 Exp(u8 x)
{
    u32 m = 1;

    while (x--) m *= 10;
    return m;
}

/*******************************************************************************
 * FunctionName : SeekStr
 * Description  : 在数据区中查找第 Idx 个字符串的起始地址
 * Param        : u8* ptr 
 * Param        : u8 Idx 
 * Return       : u8*   
*******************************************************************************/
u8* SeekStr(u8 *ptr, u8 Idx)
{
    while (Idx--) while (*ptr++);
    return ptr;
}

/*******************************************************************************
 * FunctionName : Value2Str
 * Description  : 32位数转e位有效数字符串 + 量纲字符串（结构为Unit[][6]）+  模式
 * Param        : u8* p 
 * Param        : s32 n 
 * Param        : uc8* pUnit 
 * Param        : s8 e 
 * Param        : u8 Mode 
*******************************************************************************/
void Value2Str(u8 *p, s32 n, uc8 *pUnit, s8 e, u8 Mode)
{
    s16 i = 0;
    s32 m = n, c = 5;

    if (Mode == SIGN)
    {
//      if (n == 0) *p++ = ' ';
//      if (n >  0) *p++ = '+';
        if (n <  0)
        {*p++ = '-'; n = -n;}
    } 
//  else *p++ = ' ';
 
    while (m >= 10)               // 计算 n 的有效位数 i
    {m /= 10; i++;} 
    if ((i % 3 == 2) && (e == 2)) e++;
    m = n; i = 0;
    while (m >= 10)
    {
        m /= 10;
        if (++i > e) c *= 10;     // n 的有效位数 i 大于e则计算四舍五入值
    }
    if (i >= e) n += c;           // n 加上四舍五入值
    m = n; i = 0;
    while (m >= 10)               // 重新计算 n 的有效位数 i
    {m /= 10; i++;}

    m = i / 3;                    // 计算量纲单位取值偏移量
    while (e--)
    {
        *p++ = '0' + n / Exp(i);
        if (e && (i % 3 == 0)) *p++ = '.';
        n = (i < 0) ? 0 : n % Exp(i);
        i--;
    }
    pUnit += 6 * m;                
    do
    {
        *p++ = *pUnit;
    }
    while (*pUnit++);             // 加上量纲字符字符串
}

/*******************************************************************************
 * FunctionName : u32ToStr_Unit
 * Description  : 32位数转e位有效数字符串 + 量纲字符串（结构为Unit[][6]）+  模式
 * Param        : u8* p 
 * Param        : u32 n 
 * Param        : uc8* pUnit 
 * Param        : s8 e 
*******************************************************************************/
void u32ToStr_Unit(u8 *p, u32 n, uc8 *pUnit, s8 e)
{
    s16 i = 0;
    u32 m = n, c = 5;

    while (m >= 10)               // 计算 n 的有效位数 i
    {m /= 10; i++;} 
    if ((i % 3 == 2) && (e == 2)) e++;
    m = n; i = 0;
    while (m >= 10)
    {
        m /= 10;
        if (++i > e) c *= 10;     // n 的有效位数 i 大于e则计算四舍五入值
    }
    if (i >= e) n += c;           // n 加上四舍五入值
    m = n; i = 0;
    while (m >= 10)               // 重新计算 n 的有效位数 i
    {m /= 10; i++;}

    m = i / 3;                    // 计算量纲单位取值偏移量
    while (e--)
    {
        *p++ = '0' + n / Exp(i);
        if (e && (i % 3 == 0)) *p++ = '.';
        n = (i < 0) ? 0 : n % Exp(i);
        i--;
    }
    pUnit += 6 * m;                
    do
    {
        *p++ = *pUnit;
    }
    while (*pUnit++);             // 加上量纲字符字符串
}

/*******************************************************************************
 * FunctionName : u64ToStr_Unit
 * Description  : 
 * Param        : u8* p 
 * Param        : u64 n 
 * Param        : uc8* pUnit 
 * Param        : s8 e 
 * Param        : u8 Mode 
*******************************************************************************/
void u64ToStr_Unit(u8 *p, u64 n, uc8 *pUnit, s8 e, u8 Mode)
{
    s16 i = 0;
    u32 m = n, c = 5;

    if (Mode == NEGATIVE)
    {
        *p++ = '-';
    }
/*
    else if (Mode == POSITIVE)
    {                         
        *p++ = '+';           
    }                         
    else                      
    {                         
        *p++ = ' ';           
    }                         
*/

    while (m >= 10)               // 计算 n 的有效位数 i
    {m /= 10; i++;} 
    if ((i % 3 == 2) && (e == 2)) e++;
    m = n; i = 0;
    while (m >= 10)
    {
        m /= 10;
        if (++i > e) c *= 10;     // n 的有效位数 i 大于e则计算四舍五入值
    }
    if (i >= e) n += c;           // n 加上四舍五入值
    m = n; i = 0;
    while (m >= 10)               // 重新计算 n 的有效位数 i
    {m /= 10; i++;}

    m = i / 3;                    // 计算量纲单位取值偏移量
    while (e--)
    {
        *p++ = '0' + n / Exp(i);
        if (e && (i % 3 == 0)) *p++ = '.';
        n = (i < 0) ? 0 : n % Exp(i);
        i--;
    }
    pUnit += 6 * m;                
    do
    {
        *p++ = *pUnit;
    }
    while (*pUnit++);             // 加上量纲字符字符串
}
/*******************************************************************************
 * FunctionName : ValuedivTen2Str
 * Description  : 除以10后，转换为1位有效数字
 * Param        : u8* p 
 * Param        : u16 n 
*******************************************************************************/
void ValuedivTen2Str(u8 *p, u16 n)
{
    u16 i = 0; 
    u16 m = 0;

    m = n;
    while (m >= 10)               // 计算 n 的有效位数 i
    {m /= 10; i++;}

    if (i == 0)
    {
        *p++ = '0';
        *p++ = '.';
        *p++ = '0' + n;
    } 
    else
    {
        while (i)
        {
            *p++ = '0' + n / Exp(i);
            if (i == 1) *p++ = '.';
            n =  n % Exp(i);
            i--;
        }
        *p++ = '0' + n;
    }

}
/*******************************************************************************
 * FunctionName : Str2Byte
 * Description  : Two ASCII character Change to 1 Byte HEX data
 * Param        : u8 x 
 * Param        : u8 y 
 * Return       : u8   
*******************************************************************************/
u8 Str2Byte(u8 x, u8 y) 
{
    uc8 Hexcode[17] = "0123456789ABCDEF";
    u8 i, Temp = 0;

    if (x >= 'a' && x <= 'z')  x -= 32;       // 小写改大写
    if (y >= 'a' && y <= 'z')  y -= 32;       // 小写改大写
    for (i = 0; i < 16; i++)
    {
        if (Hexcode[i] == x)  Temp += i * 16; // 将字符转为高4位十六进制数值
    }
    for (i = 0; i < 16; i++)
    {
        if (Hexcode[i] == y)  Temp += i;      // 将字符转为低4位十六进制数值
    }
    return Temp;
}

/*******************************************************************************
 * FunctionName : Char2Str
 * Description  : 1byte转换为ascii
 * Param        : u8* p 
 * Param        : u8 n 
*******************************************************************************/
void Char2Str(u8 *p, u8 n)
{
//  *p++ = '<';
    *p++ = n;
//  *p++ = '>';
    *p = 0;
}
/*******************************************************************************
 * FunctionName : u16ToDec4Str
 * Description  : 无符号16位二进制数转4位十进制字符串，有效数字前填空格
 * Param        : u8* p 
 * Param        : u16 n 
*******************************************************************************/
void u16ToDec4Str(u8 *p, u16 n)
{
    if (n / 10000)
    {
        *p++ = 'O';
        *p++ = 'v';
        *p++ = 'e';
        *p++ = 'r';
        *p   = 0;
        return;
    }
    *p++ = '0' + n / 1000;
    n %= 1000;
    *p++ = '0' + n / 100;
    n %= 100;
    *p++ = '0' + n / 10;
    n %= 10;
    *p++ = '0' + n;
    *p = 0;
    if (p[-4] == '0')
    {
        p[-4] = ' ';
        if (p[-3] == '0')
        {
            p[-3] = ' ';
            if (p[-2] == '0') p[-2] = ' ';
        }
    }
}

/*******************************************************************************
 * FunctionName : u16ToDec5Str
 * Description  : 无符号16位二进制数转5位十进制字符串
 * Param        : u8* p 
 * Param        : u16 n 
*******************************************************************************/
void u16ToDec5Str(u8 *p, u16 n)
{
    *p++ = '0' + n / 10000;
    n %= 10000;
    *p++ = '0' + n / 1000;
    n %= 1000;
    *p++ = '0' + n / 100;
    n %= 100;
    *p++ = '0' + n / 10;
    n %= 10;
    *p++ = '0' + n;
    *p = 0;
}
/*******************************************************************************
 u32ToDec10: Change 4 Byte to 10 decimal number string
*******************************************************************************/
void u32ToDecStr(u8 *p, u32 n)
{
  *p++ = '0'+n/1000000000;
  n %= 1000000000;
  *p++ = '0'+n/100000000;
  n %= 100000000;
  *p++ = '0'+n/10000000;
  n %= 10000000;
  *p++ = '0'+n/1000000;
  n %= 1000000;
  *p++ = '0'+n/100000;
  n %= 100000;
  *p++ = '0'+n/10000;
  n %= 10000;
  *p++ = '0'+n/1000;
  n %= 1000;
  *p++ = '0'+n/100;
  n %= 100;
  *p++ = '0'+n/10;
  n %= 10;
  *p++ = '0'+n;
  *p = 0;
}
/*******************************************************************************
 * FunctionName : s16ToDec5Str
 * Description  : 有符号16位二进制数转5位十进制字符串
 * Param        : u8* p 
 * Param        : s16 n 
*******************************************************************************/
void s16ToDec5Str(u8 *p, s16 n)
{
    if (n >= 0) *p++ = '+';
    else
    {*p++ = '-'; n = -n;}
    u16ToDec5Str(p, n);
}
/*******************************************************************************
 * FunctionName : u8ToDec3Str
 * Description  : Change Byte to 3 decimal number string
 * Param        : u8* p 
 * Param        : u8 n 
*******************************************************************************/
void u8ToDec3Str(u8 *p, u8 n)
{
    *p++ = '0' + n / 100;
    n %= 100;
    *p++ = '0' + n / 10;
    n %= 10;
    *p++ = '0' + n;
    *p = 0;
}
/*******************************************************************************
 * FunctionName : s8ToPercen
 * Description  : Change sign char to +(-)x.xx string
 * Param        : u8* p 
 * Param        : s8 n 
*******************************************************************************/
void s8ToPercen(u8 *p, s8 n)
{
    if (n >= 0)  *p++ = '+';
    else
    {
        *p++ = '-';
        n = -n;
    }
    *p++ = '0' + n / 100;
    n %= 100;
    *p++ = '.';
    *p++ = '0' + n / 10;
    n %= 10;
    *p++ = '0' + n;
    *p = 0;
}
/*******************************************************************************
 * FunctionName : u8ToDec2Str
 * Description  : Change Byte to 2 decimal number string
 * Param        : u8* p 
 * Param        : u8 n 
*******************************************************************************/
void u8ToDec2Str(u8 *p, u8 n)
{
//    *p++ = '0'+n/100;
    if (n>=10)
    {
        n %= 100;
        *p++ = '0' + n / 10;
    }
    n %= 10;
    *p++ = '0' + n;
    *p = 0;
}
/*******************************************************************************
 * FunctionName : u8ToDecStr
 * Description  : Change Byte to 1 decimal number string
 * Param        : u8* p 
 * Param        : u8 n 
*******************************************************************************/
void u8ToDecStr(u8 *p, u8 n)
{
//    *p++ = '0'+n/100;
//  n %= 100;
//  *p++ = '0' + n / 10;
    n %= 10;
    *p++ = '0' + n;
    *p = 0;
}
/*******************************************************************************
 * FunctionName : Char2Hex
 * Description  : Change Byte to 2 hex number string
 * Param        : u8* p 
 * Param        : u8 n 
*******************************************************************************/
void Char2Hex(u8 *p, u8 n)
{
    if (n / 16 > 9) *p++ = 'A' + (n / 16 - 10);
    else       *p++ = '0' + n / 16;
    n %= 16;
    if (n > 9)    *p++ = 'A' + (n - 10);
    else       *p++ = '0' + n;
    *p = 0;
}
/*******************************************************************************
 * FunctionName : Char2HexFullStr
 * Description  : Change Byte to 2 hex number string
 * Param        : u8* p 
 * Param        : u8 n 
*******************************************************************************/
void Char2HexFullStr(u8 *p, u8 n)
{
    *p++ = '0';
    *p++ = 'x';
    if (n / 16 > 9) *p++ = 'A' + (n / 16 - 10);
    else       *p++ = '0' + n / 16;
    n %= 16;
    if (n > 9)    *p++ = 'A' + (n - 10);
    else       *p++ = '0' + n;
    *p = 0;
}
/*******************************************************************************
 * FunctionName : Shor2Hex
 * Description  : Change 2Bytes to 4 hex number string
 * Param        : u8* p 
 * Param        : u16 n 
*******************************************************************************/
void Shor2Hex(u8 *p, u16 n)
{
    if (n / 0x1000 > 9) *p++ = 'A' + (n / 0x1000 - 10);
    else                *p++ = '0' + n / 0x1000;
    n %= 0x1000;
    if (n / 0x100 > 9)  *p++ = 'A' + (n / 0x100 - 10);
    else                *p++ = '0' + n / 0x100;
    n %= 0x100;
    if (n / 0x10 > 9)   *p++ = 'A' + (n / 0x10 - 10);
    else                *p++ = '0' + n / 0x10;
    n %= 0x10;
    if (n > 9)          *p++ = 'A' + (n - 10);
    else                *p++ = '0' + n;
    *p = 0;
}
/*******************************************************************************
 * FunctionName : Word2Hex
 * Description  : Change 4 Bytes to 8 hex number string
 * Param        : u8* p 
 * Param        : u32 n 
******************************************************************************
void Word2Hex(u8 *p, u32 n)
{
  s8 i, k;

  for(i=28; i>=0; i-=4){
    k = ((n >> i)& 0xF);
    if(k > 9) *p++ = 'A'+ k-10;
    else      *p++ = '0'+ k;
  }
  *p = 0;

}
*/
/*******************************************************************************
 * FunctionName : Sqrt32
 * Description  : unsigned int square root
 * Param        : u32 n 
 * Return       : u16   
*******************************************************************************/
u16 Sqrt32(u32 n)
{ u32 k;
    if (n == 0) return 0;
    k = 2 * Sqrt32(n / 4) + 1;
    if (k * k > n) return k - 1;
    else return k;
}
/********************************* END OF FILE ********************************/
